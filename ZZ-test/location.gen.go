// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AreaInfoShape.
const (
	AreaInfoShapeN1 AreaInfoShape = 1
	AreaInfoShapeN2 AreaInfoShape = 2
)

// Defines values for ConnectionType.
const (
	LTE     ConnectionType = "LTE"
	N5GNR   ConnectionType = "5G NR"
	UNKNOWN ConnectionType = "UNKNOWN"
	Wifi    ConnectionType = "Wifi"
	Wimax   ConnectionType = "Wimax"
)

// Defines values for DistanceCriteria.
const (
	AllBeyondDistance DistanceCriteria = "AllBeyondDistance"
	AllWithinDistance DistanceCriteria = "AllWithinDistance"
	AnyBeyondDistance DistanceCriteria = "AnyBeyondDistance"
	AnyWithinDistance DistanceCriteria = "AnyWithinDistance"
)

// Defines values for LocationEventType.
const (
	ENTERINGAREAEVENT LocationEventType = "ENTERING_AREA_EVENT"
	LEAVINGAREAEVENT  LocationEventType = "LEAVING_AREA_EVENT"
)

// Defines values for LocationInfoShape.
const (
	LocationInfoShapeN1 LocationInfoShape = 1
	LocationInfoShapeN2 LocationInfoShape = 2
	LocationInfoShapeN3 LocationInfoShape = 3
	LocationInfoShapeN4 LocationInfoShape = 4
	LocationInfoShapeN5 LocationInfoShape = 5
	LocationInfoShapeN6 LocationInfoShape = 6
	LocationInfoShapeN7 LocationInfoShape = 7
)

// Defines values for NotificationResult.
const (
	ABNORMAL NotificationResult = "ABNORMAL"
	SUCCESS  NotificationResult = "SUCCESS"
)

// Defines values for OccurrenceInfo.
const (
	MULTIPLETIMEEVENT OccurrenceInfo = "MULTIPLE_TIME_EVENT"
	ONETIMEEVENT      OccurrenceInfo = "ONE_TIME_EVENT"
)

// Defines values for OperationStatus.
const (
	Serviceable   OperationStatus = "Serviceable"
	Unknown       OperationStatus = "Unknown"
	Unserviceable OperationStatus = "Unserviceable"
)

// Defines values for VelocityVelocityType.
const (
	VelocityVelocityTypeN1 VelocityVelocityType = 1
	VelocityVelocityTypeN2 VelocityVelocityType = 2
	VelocityVelocityTypeN3 VelocityVelocityType = 3
	VelocityVelocityTypeN4 VelocityVelocityType = 4
)

// Defines values for ZoneStatusNotificationUserNumEvent.
const (
	ZoneStatusNotificationUserNumEventN1 ZoneStatusNotificationUserNumEvent = 1
	ZoneStatusNotificationUserNumEventN2 ZoneStatusNotificationUserNumEvent = 2
	ZoneStatusNotificationUserNumEventN3 ZoneStatusNotificationUserNumEvent = 3
	ZoneStatusNotificationUserNumEventN4 ZoneStatusNotificationUserNumEvent = 4
)

// AccessPointInfo A type containing access point information.
type AccessPointInfo struct {
	// AccessPointId Identifier of access point.
	AccessPointId string `json:"accessPointId"`

	// ConnectionType This enumeration represents the connection type of an access point
	ConnectionType ConnectionType `json:"connectionType"`

	// InterestRealm Interest realm of access point.
	InterestRealm *string       `json:"interestRealm,omitempty"`
	LocationInfo  *LocationInfo `json:"locationInfo,omitempty"`

	// NumberOfUsers Number of users currently on the access point.
	NumberOfUsers int `json:"numberOfUsers"`

	// OperationStatus An enumeration defining the operations status of an access point.
	OperationStatus OperationStatus `json:"operationStatus"`

	// ResourceURL Self referring URL
	ResourceURL string `json:"resourceURL"`

	// Timezone Time zone of access point.
	Timezone *string `json:"timezone,omitempty"`
}

// AccessPointList A type containing list of access points.
type AccessPointList struct {
	// AccessPoint Collection of the access point information list.
	AccessPoint *[]AccessPointInfo `json:"accessPoint,omitempty"`

	// ResourceURL Self referring URL
	ResourceURL string `json:"resourceURL"`

	// ZoneId Identifier of zone
	ZoneId string `json:"zoneId"`
}

// AreaInfo defines model for AreaInfo.
type AreaInfo struct {
	// Points Shall include one point if the shape is CIRCLE. Shall include 3-15 points if the shape is POLYGON.
	Points []Point `json:"points"`

	// Radius Shall be present if the shape is CIRCLE.
	Radius *int `json:"radius,omitempty"`

	// Shape The shape of the area monitored: 1 = CIRCLE. 2 = POLYGON
	Shape AreaInfoShape `json:"shape"`
}

// AreaInfoShape The shape of the area monitored: 1 = CIRCLE. 2 = POLYGON
type AreaInfoShape int

// CivicAddress Indicates a Civic address
type CivicAddress struct {
	// A1 National subdivisions (state, canton, region, province, prefecture)
	A1 *string `json:"A1,omitempty"`

	// A2 County, parish, gun (JP), district (IN)
	A2 *string `json:"A2,omitempty"`

	// A3 City, township, shi (JP)
	A3 *string `json:"A3,omitempty"`

	// A4 City division, borough, city district, ward, chou (JP)
	A4 *string `json:"A4,omitempty"`

	// A5 Neighbourhood, block
	A5 *string `json:"A5,omitempty"`

	// A6 Group of streets below the neighbourhood level
	A6 *string `json:"A6,omitempty"`

	// ADDCODE Additional code
	ADDCODE *string `json:"ADDCODE,omitempty"`

	// BLD Building (structure)
	BLD *string `json:"BLD,omitempty"`

	// FLR Floor
	FLR *string `json:"FLR,omitempty"`

	// HNO House number
	HNO *string `json:"HNO,omitempty"`

	// HNS House number suffix
	HNS *string `json:"HNS,omitempty"`

	// LMK Landmark or vanity address
	LMK *string `json:"LMK,omitempty"`

	// LOC Additional location information
	LOC *string `json:"LOC,omitempty"`

	// NAM Name (residence and office occupant)
	NAM *string `json:"NAM,omitempty"`

	// PC Postal/zip code
	PC *string `json:"PC,omitempty"`

	// PCN Postal community name
	PCN *string `json:"PCN,omitempty"`

	// PLC Place-type
	PLC *string `json:"PLC,omitempty"`

	// POBOX Post office box (P.O. box)
	POBOX *string `json:"POBOX,omitempty"`

	// POD Trailing street suffix
	POD *string `json:"POD,omitempty"`

	// POM Road post-modifier
	POM *string `json:"POM,omitempty"`

	// PRD Leading street direction
	PRD *string `json:"PRD,omitempty"`

	// PRM Road pre-modifier
	PRM *string `json:"PRM,omitempty"`

	// RD Primary road or street
	RD *string `json:"RD,omitempty"`

	// RDBR Road branch
	RDBR *string `json:"RDBR,omitempty"`

	// RDSEC Road clause
	RDSEC *string `json:"RDSEC,omitempty"`

	// RDSUBBR Road sub-branch
	RDSUBBR *string `json:"RDSUBBR,omitempty"`

	// ROOM Room
	ROOM *string `json:"ROOM,omitempty"`

	// SEAT Seat (desk, cubicle, workstation)
	SEAT *string `json:"SEAT,omitempty"`

	// STS Street suffix or type
	STS *string `json:"STS,omitempty"`

	// UNIT Unit (apartment, suite)
	UNIT *string `json:"UNIT,omitempty"`

	// Country The two-letter ISO 3166 country code in capital ASCII letters, e.g., DE or US
	Country string `json:"country"`

	// Method When present, this IE shall contain the method token, carried by the "method" Element of the PIDLLO XML document.
	Method *string `json:"method,omitempty"`

	// ProvidedBy When present, this IE shall carry the value of "provided-by" Element of the PIDL-LO XML document, with UTF-8 encoding.
	ProvidedBy *string `json:"providedBy,omitempty"`

	// UsageRules When present, this IE shall carry the value of "usagerules" Element of the PIDL-LO XML document, with UTF-8 encoding.
	UsageRules *string `json:"usageRules,omitempty"`
}

// ConnectionType This enumeration represents the connection type of an access point
type ConnectionType string

// DistanceCriteria An enumeration, defining the distance criteria between devices.
type DistanceCriteria string

// LinkType defines model for LinkType.
type LinkType struct {
	// Href URI referring to a resource.
	Href string `json:"href"`
}

// LocationEventType This type represents specified event types for UE location report.
type LocationEventType string

// LocationInfo defines model for LocationInfo.
type LocationInfo struct {
	// Accuracy Horizontal accuracy/(semi-major) uncertainty of location provided in meters, as defined in [14]. Present only if "shape" equals 4, 5 or 6.
	Accuracy *int `json:"accuracy,omitempty"`

	// AccuracyAltitude Altitude accuracy/uncertainty of location provided in meters, as defined in [14]. Present only if "shape" equals 3 or 4.
	AccuracyAltitude *int `json:"accuracyAltitude,omitempty"`

	// AccuracySemiMinor Horizontal accuracy/(semi-major) uncertainty of location provided in meters, as defined in [14]. Present only if "shape" equals 4, 5 or 6.
	AccuracySemiMinor *int `json:"accuracySemiMinor,omitempty"`

	// Altitude Location altitude relative to the WGS84 ellipsoid surface.
	Altitude *float32 `json:"altitude,omitempty"`

	// Confidence Confidence by which the position of a target entity is known to be within the shape description, expressed as a percentage and defined in [14]. Present only if "shape" equals 1, 4 or 6.
	Confidence *int `json:"confidence,omitempty"`

	// IncludedAngle Present only if "shape" equals 6.
	IncludedAngle *int `json:"includedAngle,omitempty"`

	// InnerRadius Present only if "shape" equals 6.
	InnerRadius *int `json:"innerRadius,omitempty"`

	// Latitude Location latitude, expressed in the range -90° to +90°. Cardinality greater than one only if "shape" equals 7.
	Latitude []float32 `json:"latitude"`

	// Longitude Location longitude, expressed in the range -180° to +180°. Cardinality greater than one only if "shape" equals 7.
	Longitude []float32 `json:"longitude"`

	// OffsetAngle Present only if "shape" equals 6.
	OffsetAngle *int `json:"offsetAngle,omitempty"`

	// OrientationMajorAxis Angle of orientation of the major axis, expressed in the range 0° to 180°, as defined in [14]. Present only if "shape" equals 4 or 6.
	OrientationMajorAxis *int `json:"orientationMajorAxis,omitempty"`

	// Shape Shape information, as detailed in [14], associated with the reported location coordinate: 1 = Ellipsoid_Arc 2 = ellipsoid_Point 3 = ellipsoid_Point_Altitude 4 = ellipsoid_Point_Altitude_Uncert_Ellipsoid 5 = ellipsoid_Point_Uncert_Circle 6 = ellipsoid_Point_Uncert_Ellipse 7 = polygon
	Shape LocationInfoShape `json:"shape"`

	// UncertaintyRadius Present only if "shape" equals 6.
	UncertaintyRadius *int `json:"uncertaintyRadius,omitempty"`

	// Velocity Structure with attributes relating to the target entity’s velocity, as defined in [14].
	Velocity *Velocity `json:"velocity,omitempty"`
}

// LocationInfoShape Shape information, as detailed in [14], associated with the reported location coordinate: 1 = Ellipsoid_Arc 2 = ellipsoid_Point 3 = ellipsoid_Point_Altitude 4 = ellipsoid_Point_Altitude_Uncert_Ellipsoid 5 = ellipsoid_Point_Uncert_Circle 6 = ellipsoid_Point_Uncert_Ellipse 7 = polygon
type LocationInfoShape int

// MapInfo defines model for MapInfo.
type MapInfo struct {
	// AncillaryMapInfo Ancillary map information may be used to convert coordinates between different coordinate systems.
	AncillaryMapInfo *map[string]interface{} `json:"ancillaryMapInfo,omitempty"`

	// MapId Indicates the ID of the map.
	MapId string `json:"mapId"`

	// Origin Indicates the location of the map origin in the local Cartesian coordinate system.
	Origin *Origin `json:"origin,omitempty"`
}

// NotificationResult This enumeration represents the result of a localization associated with a notification
type NotificationResult string

// NotificationSubscriptionList This type contains a list of subscriptions.
type NotificationSubscriptionList struct {
	ResourceURL  LinkType        `json:"resourceURL"`
	Subscription *[]Subscription `json:"subscription,omitempty"`
}

// OccurrenceInfo The enumeration OccurrenceInfo indicates whether event reporting is one time.
type OccurrenceInfo string

// OperationStatus An enumeration defining the operations status of an access point.
type OperationStatus string

// Origin Indicates the location of the map origin in the local Cartesian coordinate system.
type Origin struct {
	// Altitude Location altitude relative to the WGS84 ellipsoid surface.
	Altitude *float32 `json:"altitude,omitempty"`

	// Latitude Location latitude, expressed in the range -90° to +90°.
	Latitude float32 `json:"latitude"`

	// Longitude Location longitude, expressed in the range -180° to +180°.
	Longitude float32 `json:"longitude"`
}

// PeriodicEventInfo NOTE: reportingAmount x reportingInterval shall not exceed 8639999 (99 days, 23 hours, 59 minutes and 59 seconds) for compatibility with OMA MLP and RLP.
type PeriodicEventInfo struct {
	// ReportingAmount Number of event reports
	ReportingAmount float32 `json:"reportingAmount"`

	// ReportingInterval Interval of event reports
	ReportingInterval float32 `json:"reportingInterval"`
}

// Point defines model for Point.
type Point struct {
	// Latitude Location latitude, expressed in the range -90° to +90°.
	Latitude float32 `json:"latitude"`

	// Longitude Location longitude, expressed in the range -180° to +180°.
	Longitude float32 `json:"longitude"`
}

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code for this occurrence of the problem
	Status *uint32 `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type
	Title *string `json:"title,omitempty"`

	// Type A URI reference according to IETF RFC 3986 that identifies the problem type
	Type *string `json:"type,omitempty"`
}

// RelativeLocationInfo defines model for RelativeLocationInfo.
type RelativeLocationInfo struct {
	// X Indicates the value (in the unit of meters) on x-axis of the relative location in the Cartesian system. Positive value represents easting from origin.
	X float32 `json:"X"`

	// Y Indicates the value (in the unit of meters) on y-axis of the relative location in the Cartesian system. Positive value represents northing from origin.
	Y float32 `json:"Y"`

	// Z Indicates the value (in the unit of meters) on z-axis of the relative location in the Cartesian system for a 3DPoint. Positive value represents height above origin.
	Z       *float32 `json:"Z,omitempty"`
	MapInfo MapInfo  `json:"mapInfo"`
}

// ReportingCtrl defines model for ReportingCtrl.
type ReportingCtrl struct {
	// MaximumCount Maximum number of notifications. For no maximum, either do not include this element or specify a value of zero. Default value is 0.
	MaximumCount *int `json:"maximumCount,omitempty"`

	// MaximumFrequency Maximum frequency (in seconds) of notifications per subscription.
	MaximumFrequency *int `json:"maximumFrequency,omitempty"`

	// MinimumInterval Minimum interval between reports in case frequently reporting. Unit is second.
	MinimumInterval *int `json:"minimumInterval,omitempty"`
}

// Subscription defines model for Subscription.
type Subscription struct {
	// Href The URI referring to the subscription.
	Href string `json:"href"`

	// SubscriptionType Type of the subscription. The string shall be set according to the "subscriptionType" attribute of the associated subscription data type defined in clauses 6.3.4, 6.3.5, 6.3.6, 6.3.7 6.3.8 and 6.3.9:
	// "UserLocationEventSubscription"
	// "UserLocationPeriodicSubscription"
	// "ZoneLocationEventSubscription"
	// "ZoneStatusSubscription"
	// "UserAreaSubscription"
	// "UserDistanceSubscription"
	SubscriptionType string `json:"subscriptionType"`
}

// TerminalDistance A type containing information about the distance from a terminal to a location or between two terminals, in addition the accuracy and a timestamp of the information are provided.
type TerminalDistance struct {
	// Accuracy Accuracy of the provided distance in meters
	Accuracy *int `json:"accuracy,omitempty"`

	// Distance Distance from terminal to a location or between two terminals specified in meters
	Distance  int        `json:"distance"`
	Timestamp *TimeStamp `json:"timestamp,omitempty"`
}

// TimeStamp defines model for TimeStamp.
type TimeStamp struct {
	// NanoSeconds The nanoseconds part of the time. Time is defined as Unix-time since January 1, 1970, 00:00:00 UTC.
	NanoSeconds uint32 `json:"nanoSeconds"`

	// Seconds The seconds part of the time. Time is defined as Unix-time since January 1, 1970, 00:00:00 UTC.
	Seconds uint32 `json:"seconds"`
}

// UserAreaNotification defines model for UserAreaNotification.
type UserAreaNotification struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links Links `json:"_links"`

	// Address Address of user (e.g. ‘sip’ URI, ‘tel’ URI, ‘acr’ URI).
	Address string `json:"address"`

	// CivicInfo Indicates a Civic address
	CivicInfo    *CivicAddress `json:"civicInfo,omitempty"`
	LocationInfo *LocationInfo `json:"locationInfo,omitempty"`

	// NotificationType Shall be set to "UserAreaNotification".
	NotificationType     string                `json:"notificationType"`
	RelativeLocationInfo *RelativeLocationInfo `json:"relativeLocationInfo,omitempty"`
	TimeStamp            *TimeStamp            `json:"timeStamp,omitempty"`

	// UserLocationEvent This type represents specified event types for UE location report.
	UserLocationEvent LocationEventType `json:"userLocationEvent"`
}

// UserAreaSubscription defines model for UserAreaSubscription.
type UserAreaSubscription struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links *Links `json:"_links,omitempty"`

	// AddressList List of the users to be monitored.
	AddressList []string `json:"addressList"`
	AreaDefine  AreaInfo `json:"areaDefine"`

	// CallbackReference URI exposed by the client on which to receive notifications via HTTP. See note 1.
	CallbackReference *string `json:"callbackReference,omitempty"`

	// ClientCorrelator A correlator that the client can use to tag this particular resource representation during a request to create a resource on the server. See note 2.
	ClientCorrelator *string    `json:"clientCorrelator,omitempty"`
	ExpiryDeadline   *TimeStamp `json:"expiryDeadline,omitempty"`

	// LocationEventCriteria List of user event values to generate notifications for (these apply to address specified).
	LocationEventCriteria *[]LocationEventType `json:"locationEventCriteria,omitempty"`
	ReportingCtrl         *ReportingCtrl       `json:"reportingCtrl,omitempty"`

	// ReportingLocationReq This IE shall be set to true if a location estimate is required for each event report.
	ReportingLocationReq *bool `json:"reportingLocationReq,omitempty"`

	// RequestTestNotification Set to TRUE by the service consumer to request a test notification via HTTP on the callbackReference URI, as specified in ETSI GS MEC 009 [4], clause 6.12a.
	RequestTestNotification *bool `json:"requestTestNotification,omitempty"`

	// SubscriptionType Shall be set to "UserAreaSubscription".
	SubscriptionType string `json:"subscriptionType"`

	// TrackingAccuracy Number of meters of acceptable error.
	TrackingAccuracy   float32             `json:"trackingAccuracy"`
	WebsockNotifConfig *WebsockNotifConfig `json:"websockNotifConfig,omitempty"`
}

// UserDistanceNotification defines model for UserDistanceNotification.
type UserDistanceNotification struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links Links `json:"_links"`

	// DistanceEvent An enumeration, defining the distance criteria between devices.
	DistanceEvent DistanceCriteria `json:"distanceEvent"`

	// MonitoredUsers A type containing list of users.
	MonitoredUsers UserList `json:"monitoredUsers"`

	// NotificationType Shall be set to "UserDistanceNotification".
	NotificationType string     `json:"notificationType"`
	TimeStamp        *TimeStamp `json:"timeStamp,omitempty"`
}

// UserDistanceSubscription defines model for UserDistanceSubscription.
type UserDistanceSubscription struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links *Links `json:"_links,omitempty"`

	// CallbackReference URI exposed by the client on which to receive notifications via HTTP. See note 1.
	CallbackReference *string `json:"callbackReference,omitempty"`
	CheckImmediate    bool    `json:"checkImmediate"`

	// ClientCorrelator A correlator that the client can use to tag this particular resource representation during a request to create a resource on the server. See note 2.
	ClientCorrelator *string `json:"clientCorrelator,omitempty"`

	// Criteria An enumeration, defining the distance criteria between devices.
	Criteria DistanceCriteria `json:"criteria"`

	// Distance Distance between users that shall be monitored. The unit is meter.
	Distance       float32    `json:"distance"`
	ExpiryDeadline *TimeStamp `json:"expiryDeadline,omitempty"`

	// MonitoredAddress Contains addresses of users to monitor (e.g., ‘sip’ URI, ‘tel’ URI, ‘acr’ URI). Reference to a group could be provided here if supported by implementation.
	// If the ReferenceAddress is specified, then the distance between each monitored user and reference user(s) will be monitored.
	// If the ReferenceAddress is not present, then the distance between each pair of the monitored users will be monitored. Note that in that case there shall be at least two addresses specified here.
	MonitoredAddress []string `json:"monitoredAddress"`

	// ReferenceAddress If specified, indicates address of each user that will be used as reference users from which the distances towards monitored users indicated in the Addresses will be monitored (e.g., ‘sip’ URI, ‘tel’ URI, ‘acr’ URI). Reference to a group could be provided here if supported by implementation.
	ReferenceAddress *[]string      `json:"referenceAddress,omitempty"`
	ReportingCtrl    *ReportingCtrl `json:"reportingCtrl,omitempty"`

	// RequestTestNotification Set to TRUE by the service consumer to request a test notification via HTTP on the callbackReference URI, as specified in ETSI GS MEC 009 [4], clause 6.12a.
	RequestTestNotification *bool `json:"requestTestNotification,omitempty"`

	// SubscriptionType Shall be set to "UserDistanceSubscription".
	SubscriptionType string `json:"subscriptionType"`

	// TrackingAccuracy Number of meters of acceptable error in tracking distance.
	TrackingAccuracy   float32             `json:"trackingAccuracy"`
	WebsockNotifConfig *WebsockNotifConfig `json:"websockNotifConfig,omitempty"`
}

// UserEventPara defines model for UserEventPara.
type UserEventPara struct {
	// AccessPointList One or more access points forming a monitoring area that could be any shape. See note 1.
	AccessPointList *[]string `json:"accessPointList,omitempty"`

	// OccurrenceInfo The enumeration OccurrenceInfo indicates whether event reporting is one time.
	OccurrenceInfo *OccurrenceInfo `json:"occurrenceInfo,omitempty"`

	// ReportingLocationReq This IE shall be set to true if a location estimate is required for each event report.
	ReportingLocationReq *bool `json:"reportingLocationReq,omitempty"`

	// ZoneId Identifier of zone (e.g. zone001) to monitor. See note 1.
	ZoneId *string `json:"zoneId,omitempty"`
}

// UserInfo This type represents the information related to a user attached to an access point associated to the MEC host, such access point is in scope of the Location Service instance.
type UserInfo struct {
	// AccessPointId The identity of the access point the user is currently on, see note 1.
	AccessPointId *string `json:"AccessPointId,omitempty"`

	// Address Address of user (e.g. 'sip' URI, 'tel' URI, 'acr' URI) currently on the access point, see note 1.
	Address string `json:"address"`

	// AncillaryInfo Reserved for future use.
	AncillaryInfo *string `json:"ancillaryInfo,omitempty"`

	// CivicInfo Indicates a Civic address
	CivicInfo            *CivicAddress         `json:"civicInfo,omitempty"`
	LocationInfo         *LocationInfo         `json:"locationInfo,omitempty"`
	RelativeLocationInfo *RelativeLocationInfo `json:"relativeLocationInfo,omitempty"`

	// ResourceURL Self-referring URL, see note 1.
	ResourceURL string    `json:"resourceURL"`
	Timestamp   TimeStamp `json:"timestamp"`

	// ZoneId The identity of the zone the user is currently within, see note 1.
	ZoneId string `json:"zoneId"`
}

// UserList A type containing list of users.
type UserList struct {
	// ResourceURL Self referring URL
	ResourceURL string `json:"resourceURL"`

	// User Collection of the zone information list.
	User *[]UserInfo `json:"user,omitempty"`
}

// UserLocationEventNotification defines model for UserLocationEventNotification.
type UserLocationEventNotification struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links Links `json:"_links"`

	// AccessPointId The identity of the access point.
	// For the events of "ENTERING_AREA_EVENT", it indicates the access point that the user is currently within.
	// For the event of "LEAVING_AREA_EVENT", it indicates the access point that the user used to be within.
	// See note 2.
	AccessPointId *string `json:"accessPointId,omitempty"`

	// Address Address of user (e.g. ‘sip’ URI, ‘tel’ URI, ‘acr’ URI).
	Address *string `json:"address,omitempty"`

	// CivicInfo Indicates a Civic address
	CivicInfo    *CivicAddress `json:"civicInfo,omitempty"`
	LocationInfo *LocationInfo `json:"locationInfo,omitempty"`

	// NotificationType Shall be set to "UserLocationEventNotification".
	NotificationType     string                `json:"notificationType"`
	RelativeLocationInfo *RelativeLocationInfo `json:"relativeLocationInfo,omitempty"`
	TimeStamp            *TimeStamp            `json:"timeStamp,omitempty"`

	// UserLocationEvent This type represents specified event types for UE location report.
	UserLocationEvent LocationEventType `json:"userLocationEvent"`

	// ZoneId The identity of the zone.
	// For the events of "ENTERING_AREA_EVENT", it is the zone that the user is currently within.
	// For the event of "LEAVING_AREA_EVENT", it is the zone that the user used to be within.
	// See note 2.
	ZoneId *string `json:"zoneId,omitempty"`
}

// UserLocationEventSubscription defines model for UserLocationEventSubscription.
type UserLocationEventSubscription struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links *Links `json:"_links,omitempty"`

	// Address Address of user (e.g. ‘sip’ URI, ‘tel’ URI, ‘acr’ URI) to monitor.
	Address string `json:"address"`

	// CallbackReference URI exposed by the client on which to receive notifications via HTTP. See note 1.
	CallbackReference *string `json:"callbackReference,omitempty"`

	// ClientCorrelator A correlator that the client can use to tag this particular resource representation during a request to create a resource on the server. See note 2.
	ClientCorrelator *string    `json:"clientCorrelator,omitempty"`
	ExpiryDeadline   *TimeStamp `json:"expiryDeadline,omitempty"`

	// LocationEventCriteria List of user event values to generate notifications for (these apply to address specified).
	LocationEventCriteria *[]LocationEventType `json:"locationEventCriteria,omitempty"`

	// RequestTestNotification Set to TRUE by the service consumer to request a test notification via HTTP on the callbackReference URI, as specified in ETSI GS MEC 009 [4], clause 6.12a.
	RequestTestNotification *bool `json:"requestTestNotification,omitempty"`

	// SubscriptionType Shall be set to "UserLocationEventSubscription".
	SubscriptionType   string              `json:"subscriptionType"`
	UserEventPara      *UserEventPara      `json:"userEventPara,omitempty"`
	WebsockNotifConfig *WebsockNotifConfig `json:"websockNotifConfig,omitempty"`
}

// UserLocationPeriodicNotification defines model for UserLocationPeriodicNotification.
type UserLocationPeriodicNotification struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links Links `json:"_links"`

	// AccessPointId The identity of the access point that the user is currently within.
	// See note 2.
	AccessPointId *string `json:"accessPointId,omitempty"`

	// Address Address of user (e.g. ‘sip’ URI, ‘tel’ URI, ‘acr’ URI).
	Address *string `json:"address,omitempty"`

	// CivicInfo Indicates a Civic address
	CivicInfo *CivicAddress `json:"civicInfo,omitempty"`

	// IsFinalNotification Shall be set to true if it is a final notification.
	IsFinalNotification *bool         `json:"isFinalNotification,omitempty"`
	LocationInfo        *LocationInfo `json:"locationInfo,omitempty"`

	// NotificationType Shall be set to "UserLocationPeriodicNotification".
	NotificationType     string                `json:"notificationType"`
	RelativeLocationInfo *RelativeLocationInfo `json:"relativeLocationInfo,omitempty"`

	// Result This enumeration represents the result of a localization associated with a notification
	Result    NotificationResult `json:"result"`
	TimeStamp *TimeStamp         `json:"timeStamp,omitempty"`

	// ZoneId The identity of the zone that the user is currently within.
	// See note 2.
	ZoneId *string `json:"zoneId,omitempty"`
}

// UserLocationPeriodicSubscription defines model for UserLocationPeriodicSubscription.
type UserLocationPeriodicSubscription struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links *Links `json:"_links,omitempty"`

	// Address Address of user (e.g. ‘sip’ URI, ‘tel’ URI, ‘acr’ URI) to monitor.
	Address string `json:"address"`

	// CallbackReference URI exposed by the client on which to receive notifications via HTTP. See note 1.
	CallbackReference *string `json:"callbackReference,omitempty"`

	// ClientCorrelator A correlator that the client can use to tag this particular resource representation during a request to create a resource on the server. See note 2.
	ClientCorrelator *string    `json:"clientCorrelator,omitempty"`
	ExpiryDeadline   *TimeStamp `json:"expiryDeadline,omitempty"`

	// PeriodicEventInfo NOTE: reportingAmount x reportingInterval shall not exceed 8639999 (99 days, 23 hours, 59 minutes and 59 seconds) for compatibility with OMA MLP and RLP.
	PeriodicEventInfo PeriodicEventInfo `json:"periodicEventInfo"`

	// RequestTestNotification Set to TRUE by the service consumer to request a test notification via HTTP on the callbackReference URI, as specified in ETSI GS MEC 009 [4], clause 6.12a.
	RequestTestNotification *bool `json:"requestTestNotification,omitempty"`

	// SubscriptionType Shall be set to "UserLocationPeriodicSubscription".
	SubscriptionType   string              `json:"subscriptionType"`
	WebsockNotifConfig *WebsockNotifConfig `json:"websockNotifConfig,omitempty"`
}

// Velocity Structure with attributes relating to the target entity’s velocity, as defined in [14].
type Velocity struct {
	// Bearing Bearing, expressed in the range 0° to 360°, as defined in [14].
	Bearing int `json:"bearing"`

	// HorizontalSpeed Horizontal speed, expressed in km/h and defined in [14].
	HorizontalSpeed int `json:"horizontalSpeed"`

	// Uncertainty Horizontal uncertainty, as defined in [14]. Present only if "velocityType" equals 3 or 4.
	Uncertainty *int `json:"uncertainty,omitempty"`

	// VelocityType Velocity information, as detailed in [14], associated with the reported location coordinate: 1 = Horizontal 2 = Horizontal_Vertical 3 = Horizontal_Uncert 4 = Horizontal_Vertical_Uncert
	VelocityType VelocityVelocityType `json:"velocityType"`

	// VerticalSpeed Vertical speed, expressed in km/h and defined in [14]. Present only if "velocityType" equals 2 or 4.
	VerticalSpeed *int `json:"verticalSpeed,omitempty"`

	// VerticalUncertainty Vertical uncertainty, as defined in [14]. Present only if "velocityType" equals 4.
	VerticalUncertainty *int `json:"verticalUncertainty,omitempty"`
}

// VelocityVelocityType Velocity information, as detailed in [14], associated with the reported location coordinate: 1 = Horizontal 2 = Horizontal_Vertical 3 = Horizontal_Uncert 4 = Horizontal_Vertical_Uncert
type VelocityVelocityType int

// WebsockNotifConfig defines model for WebsockNotifConfig.
type WebsockNotifConfig struct {
	// RequestWebsocketUri Set to true by the service consumer to indicate that Websocket delivery is requested.
	RequestWebsocketUri *bool `json:"requestWebsocketUri,omitempty"`

	// WebsocketUri Set by location server to indicate to the service consumer the Websocket URI to be used for delivering notifications.
	WebsocketUri *string `json:"websocketUri,omitempty"`
}

// ZoneInfo A type containing zone information.
type ZoneInfo struct {
	// NumberOfAccessPoints The number of access points within the zone
	NumberOfAccessPoints int `json:"numberOfAccessPoints"`

	// NumberOfUnserviceableAccessPoints Number of inoperable access points within the zone.
	NumberOfUnserviceableAccessPoints int `json:"numberOfUnserviceableAccessPoints"`

	// NumberOfUsers The number of users currently on the access point.
	NumberOfUsers int `json:"numberOfUsers"`

	// ResourceURL Self referring URL
	ResourceURL string `json:"resourceURL"`

	// ZoneId Identifier of zone
	ZoneId string `json:"zoneId"`
}

// ZoneList A type containing a list of zones.
type ZoneList struct {
	// ResourceURL Self referring URL
	ResourceURL string `json:"resourceURL"`

	// Zone Collection of the zone information list.
	Zone *[]ZoneInfo `json:"zone,omitempty"`
}

// ZoneLocationEventNotification defines model for ZoneLocationEventNotification.
type ZoneLocationEventNotification struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links Links `json:"_links"`

	// Address Address of user (e.g. ‘sip’ URI, ‘tel’ URI, ‘acr’ URI).
	Address string `json:"address"`

	// NotificationType Shall be set to "ZoneLocationEventNotification".
	NotificationType string     `json:"notificationType"`
	TimeStamp        *TimeStamp `json:"timeStamp,omitempty"`

	// UserLocationEvent This type represents specified event types for UE location report.
	UserLocationEvent LocationEventType `json:"userLocationEvent"`

	// ZoneId The identity of the zone.
	ZoneId string `json:"zoneId"`
}

// ZoneLocationEventSubscription defines model for ZoneLocationEventSubscription.
type ZoneLocationEventSubscription struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links *Links `json:"_links,omitempty"`

	// AddressList List of the users to be monitored. If not present, all the users need to be monitored.
	AddressList *[]string `json:"addressList,omitempty"`

	// CallbackReference URI exposed by the client on which to receive notifications via HTTP. See note 1.
	CallbackReference *string `json:"callbackReference,omitempty"`

	// ClientCorrelator A correlator that the client can use to tag this particular resource representation during a request to create a resource on the server. See note 2.
	ClientCorrelator *string    `json:"clientCorrelator,omitempty"`
	ExpiryDeadline   *TimeStamp `json:"expiryDeadline,omitempty"`

	// LocationEventCriteria List of user event values to generate notifications for.
	LocationEventCriteria *[]LocationEventType `json:"locationEventCriteria,omitempty"`
	ReportingCtrl         *ReportingCtrl       `json:"reportingCtrl,omitempty"`

	// RequestTestNotification Set to TRUE by the service consumer to request a test notification via HTTP on the callbackReference URI, as specified in ETSI GS MEC 009 [4], clause 6.12a.
	RequestTestNotification *bool `json:"requestTestNotification,omitempty"`

	// SubscriptionType Shall be set to "ZoneLocationEventSubscription".
	SubscriptionType   string              `json:"subscriptionType"`
	WebsockNotifConfig *WebsockNotifConfig `json:"websockNotifConfig,omitempty"`

	// ZoneId Identifier of zone (e.g. zone001) to monitor.
	ZoneId string `json:"zoneId"`
}

// ZoneStatusNotification defines model for ZoneStatusNotification.
type ZoneStatusNotification struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links Links `json:"_links"`

	// AccessPointId Identifier of an access point (e.g. ap01). Shall be included when userNumEvent related with access point or operationStatus is included.
	AccessPointId *string `json:"accessPointId,omitempty"`

	// NotificationType Shall be set to "ZoneStatusNotification".
	NotificationType string `json:"notificationType"`

	// OperationStatus An enumeration defining the operations status of an access point.
	OperationStatus *OperationStatus `json:"operationStatus,omitempty"`
	TimeStamp       *TimeStamp       `json:"timeStamp,omitempty"`

	// UserNumEvent Shall be present when ZoneStatusSubscription includes upperNumberOfUsersZoneThreshold, lowerNumberOfUsersZoneThreshold, upperNumberOfUsersAPThreshold or lowerNumberOfUsersAPThreshold, and the number of users in a zone or an access point crosses the threshold defined in the subscription: 1 = OVER_ZONE_UPPER_THD. 2 = UNDER_ZONE_LOWER_THD. 3 = OVER_AP_UPPER_THD. 4 = UNDER_AP_LOWER_THD.
	UserNumEvent *ZoneStatusNotificationUserNumEvent `json:"userNumEvent,omitempty"`

	// ZoneId The identity of the zone.
	ZoneId string `json:"zoneId"`
}

// ZoneStatusNotificationUserNumEvent Shall be present when ZoneStatusSubscription includes upperNumberOfUsersZoneThreshold, lowerNumberOfUsersZoneThreshold, upperNumberOfUsersAPThreshold or lowerNumberOfUsersAPThreshold, and the number of users in a zone or an access point crosses the threshold defined in the subscription: 1 = OVER_ZONE_UPPER_THD. 2 = UNDER_ZONE_LOWER_THD. 3 = OVER_AP_UPPER_THD. 4 = UNDER_AP_LOWER_THD.
type ZoneStatusNotificationUserNumEvent int

// ZoneStatusSubscription defines model for ZoneStatusSubscription.
type ZoneStatusSubscription struct {
	// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
	Links *Links `json:"_links,omitempty"`

	// CallbackReference URI exposed by the client on which to receive notifications via HTTP. See note 1.
	CallbackReference *string `json:"callbackReference,omitempty"`

	// ClientCorrelator A correlator that the client can use to tag this particular resource representation during a request to create a resource on the server. See note 2.
	ClientCorrelator *string    `json:"clientCorrelator,omitempty"`
	ExpiryDeadline   *TimeStamp `json:"expiryDeadline,omitempty"`

	// LowerNumberOfUsersAPThreshold Threshold number of users in an access point which if crossed downward shall cause a notification
	LowerNumberOfUsersAPThreshold *int `json:"lowerNumberOfUsersAPThreshold,omitempty"`

	// LowerNumberOfUsersZoneThreshold Threshold number of users in a zone which if crossed downward shall cause a notification
	LowerNumberOfUsersZoneThreshold *int `json:"lowerNumberOfUsersZoneThreshold,omitempty"`

	// OperationStatus List of operation status values to generate notifications for (these apply to all access points within a zone). See note 3.
	OperationStatus *[]OperationStatus `json:"operationStatus,omitempty"`
	ReportingCtrl   *ReportingCtrl     `json:"reportingCtrl,omitempty"`

	// RequestTestNotification Set to TRUE by the service consumer to request a test notification via HTTP on the callbackReference URI, as specified in ETSI GS MEC 009 [4], clause 6.12a.
	RequestTestNotification *bool `json:"requestTestNotification,omitempty"`

	// SubscriptionType Shall be set to "ZoneStatusSubscription".
	SubscriptionType string `json:"subscriptionType"`

	// UpperNumberOfUsersAPThreshold Threshold number of users in an access point which if crossed upward shall cause a notification.
	UpperNumberOfUsersAPThreshold *int `json:"upperNumberOfUsersAPThreshold,omitempty"`

	// UpperNumberOfUsersZoneThreshold Threshold number of users in a zone which if crossed upward shall cause a notification.
	UpperNumberOfUsersZoneThreshold *int                `json:"upperNumberOfUsersZoneThreshold,omitempty"`
	WebsockNotifConfig              *WebsockNotifConfig `json:"websockNotifConfig,omitempty"`

	// ZoneId Identifier of zone (e.g. zone001) to monitor.
	ZoneId string `json:"zoneId"`
}

// Links Hyperlink related to the resource. This shall be only included in the HTTP responses and in HTTP PUT requests.
type Links struct {
	Self LinkType `json:"self"`
}

// PathAccessPointId defines model for Path.AccessPointId.
type PathAccessPointId = string

// PathSubscrId defines model for Path.SubscrId.
type PathSubscrId = string

// PathZoneId defines model for Path.ZoneId.
type PathZoneId = string

// QueryAccessPointId defines model for Query.AccessPointId.
type QueryAccessPointId = []string

// QueryAddress defines model for Query.Address.
type QueryAddress = []string

// QueryAddress2 defines model for Query.Address_2.
type QueryAddress2 = string

// QueryAddress3 defines model for Query.Address_3.
type QueryAddress3 = []string

// QueryLocation defines model for Query.Location.
type QueryLocation struct {
	// Latitude Location latitude, expressed in the range -90° to +90°.
	Latitude *float32 `json:"latitude,omitempty"`

	// Longitude Location longitude, expressed in the range -180° to +180°.
	Longitude *float32 `json:"longitude,omitempty"`
}

// QuerySubscriptionType defines model for Query.Subscription_type.
type QuerySubscriptionType = string

// QuerySubscriptionType2 defines model for Query.Subscription_type_2.
type QuerySubscriptionType2 = string

// QuerySubscriptionType3 defines model for Query.Subscription_type_3.
type QuerySubscriptionType3 = string

// QueryZoneId defines model for Query.ZoneId.
type QueryZoneId = []string

// QueryZoneId2 defines model for Query.ZoneId_2.
type QueryZoneId2 = string

// N400 defines model for 400.
type N400 = ProblemDetails

// N401 defines model for 401.
type N401 = ProblemDetails

// N403 defines model for 403.
type N403 = ProblemDetails

// N404 defines model for 404.
type N404 = ProblemDetails

// N406 defines model for 406.
type N406 = ProblemDetails

// N412 defines model for 412.
type N412 = ProblemDetails

// N415 defines model for 415.
type N415 = ProblemDetails

// N422 defines model for 422.
type N422 = ProblemDetails

// N429 defines model for 429.
type N429 = ProblemDetails

// DistanceGETParams defines parameters for DistanceGET.
type DistanceGETParams struct {
	// Address One or two addresses of user to check. The second "address" parameter shall not be included when the distance between a user and a location is requested. The second "address" parameter shall be included when a location is not provided.
	Address *QueryAddress `form:"address,omitempty" json:"address,omitempty"`

	// Location Shall not be included when the distance between two terminals is requested.
	Location *QueryLocation `form:"location,omitempty" json:"location,omitempty"`
}

// UsersGETParams defines parameters for UsersGET.
type UsersGETParams struct {
	// ZoneId Identifier of zone
	ZoneId *QueryZoneId `form:"zoneId,omitempty" json:"zoneId,omitempty"`

	// AccessPointId Identifier of access point
	AccessPointId *QueryAccessPointId `form:"accessPointId,omitempty" json:"accessPointId,omitempty"`

	// Address Address of user (e.g. 'sip' URI, 'tel' URI, 'acr' URI).
	Address *QueryAddress3 `form:"address,omitempty" json:"address,omitempty"`
}

// ZonesGETParams defines parameters for ZonesGET.
type ZonesGETParams struct {
	// ZoneId Identifier of zone
	ZoneId *QueryZoneId `form:"zoneId,omitempty" json:"zoneId,omitempty"`
}

// AccessPointsGETParams defines parameters for AccessPointsGET.
type AccessPointsGETParams struct {
	// AccessPointId Identifier of access point
	AccessPointId *QueryAccessPointId `form:"accessPointId,omitempty" json:"accessPointId,omitempty"`
}

// AreaSubListGETParams defines parameters for AreaSubListGET.
type AreaSubListGETParams struct {
	// SubscriptionType Query parameter to filter on a specific subscription type. Permitted values: event
	SubscriptionType *QuerySubscriptionType `form:"subscription_type,omitempty" json:"subscription_type,omitempty"`
}

// AreaSubPOSTJSONBody defines parameters for AreaSubPOST.
type AreaSubPOSTJSONBody struct {
	UserAreaSubscription *UserAreaSubscription `json:"userAreaSubscription,omitempty"`
}

// AreaSubPUTJSONBody defines parameters for AreaSubPUT.
type AreaSubPUTJSONBody struct {
	UserAreaNotification *UserAreaNotification `json:"userAreaNotification,omitempty"`
}

// DistanceSubPOSTJSONBody defines parameters for DistanceSubPOST.
type DistanceSubPOSTJSONBody struct {
	UserDistanceSubscription *UserDistanceSubscription `json:"userDistanceSubscription,omitempty"`
}

// DistanceSubPUTJSONBody defines parameters for DistanceSubPUT.
type DistanceSubPUTJSONBody struct {
	UserDistanceSubscription *UserDistanceSubscription `json:"userDistanceSubscription,omitempty"`
}

// UserSubListGETParams defines parameters for UserSubListGET.
type UserSubListGETParams struct {
	// SubscriptionType Query parameter to filter on a specific subscription type. Permitted values: -event -periodic
	SubscriptionType *QuerySubscriptionType2 `form:"subscription_type,omitempty" json:"subscription_type,omitempty"`

	// Address Address of user (e.g. 'sip' URI, 'tel' URI, 'acr' URI).
	Address *QueryAddress2 `form:"address,omitempty" json:"address,omitempty"`
}

// UserSubPOSTJSONBody defines parameters for UserSubPOST.
type UserSubPOSTJSONBody struct {
	UserLocationEventSubscription    *UserLocationEventSubscription    `json:"userLocationEventSubscription,omitempty"`
	UserLocationPeriodicSubscription *UserLocationPeriodicSubscription `json:"userLocationPeriodicSubscription,omitempty"`
}

// UserSubPUTJSONBody defines parameters for UserSubPUT.
type UserSubPUTJSONBody struct {
	UserLocationEventSubscription    *UserLocationEventSubscription    `json:"userLocationEventSubscription,omitempty"`
	UserLocationPeriodicSubscription *UserLocationPeriodicSubscription `json:"userLocationPeriodicSubscription,omitempty"`
}

// ZoneSubListGETParams defines parameters for ZoneSubListGET.
type ZoneSubListGETParams struct {
	// SubscriptionType Query parameter to filter on a specific subscription type. Permitted values: -event -status
	SubscriptionType *QuerySubscriptionType3 `form:"subscription_type,omitempty" json:"subscription_type,omitempty"`

	// ZoneId The identity of the zone
	ZoneId *QueryZoneId2 `form:"zoneId,omitempty" json:"zoneId,omitempty"`
}

// ZoneSubPOSTJSONBody defines parameters for ZoneSubPOST.
type ZoneSubPOSTJSONBody struct {
	ZoneLocationEventSubscription *ZoneLocationEventSubscription `json:"zoneLocationEventSubscription,omitempty"`
	ZoneStatusSubscription        *ZoneStatusSubscription        `json:"zoneStatusSubscription,omitempty"`
}

// ZoneSubPUTJSONBody defines parameters for ZoneSubPUT.
type ZoneSubPUTJSONBody struct {
	ZoneLocationEventSubscription *ZoneLocationEventSubscription `json:"zoneLocationEventSubscription,omitempty"`
	ZoneStatusSubscription        *ZoneStatusSubscription        `json:"zoneStatusSubscription,omitempty"`
}

// AreaSubPOSTJSONRequestBody defines body for AreaSubPOST for application/json ContentType.
type AreaSubPOSTJSONRequestBody AreaSubPOSTJSONBody

// AreaSubPUTJSONRequestBody defines body for AreaSubPUT for application/json ContentType.
type AreaSubPUTJSONRequestBody AreaSubPUTJSONBody

// DistanceSubPOSTJSONRequestBody defines body for DistanceSubPOST for application/json ContentType.
type DistanceSubPOSTJSONRequestBody DistanceSubPOSTJSONBody

// DistanceSubPUTJSONRequestBody defines body for DistanceSubPUT for application/json ContentType.
type DistanceSubPUTJSONRequestBody DistanceSubPUTJSONBody

// UserSubPOSTJSONRequestBody defines body for UserSubPOST for application/json ContentType.
type UserSubPOSTJSONRequestBody UserSubPOSTJSONBody

// UserSubPUTJSONRequestBody defines body for UserSubPUT for application/json ContentType.
type UserSubPUTJSONRequestBody UserSubPUTJSONBody

// ZoneSubPOSTJSONRequestBody defines body for ZoneSubPOST for application/json ContentType.
type ZoneSubPOSTJSONRequestBody ZoneSubPOSTJSONBody

// ZoneSubPUTJSONRequestBody defines body for ZoneSubPUT for application/json ContentType.
type ZoneSubPUTJSONRequestBody ZoneSubPUTJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Query information about distance from a user to a location or between two users
	// (GET /queries/distance)
	DistanceGET(c *gin.Context, params DistanceGETParams)
	// Query location information about a specific UE or a group of Ues
	// (GET /queries/users)
	UsersGET(c *gin.Context, params UsersGETParams)
	// Query the information about one or more specific zones or a list of zones.
	// (GET /queries/zones)
	ZonesGET(c *gin.Context, params ZonesGETParams)
	// Query information about a specific zone
	// (GET /queries/zones/{zoneId})
	ZoneGetById(c *gin.Context, zoneId PathZoneId)
	// Query information about a specific access point or a list of access points under a zone
	// (GET /queries/zones/{zoneId}/accessPoints)
	AccessPointsGET(c *gin.Context, zoneId PathZoneId, params AccessPointsGETParams)
	// Query information about a specific access point under a zone.
	// (GET /queries/zones/{zoneId}/accessPoints/{accessPointId})
	AccessPointGetById(c *gin.Context, zoneId PathZoneId, accessPointId PathAccessPointId)
	// Retrieves information about the subscriptions for this requestor.
	// (GET /subscriptions/area)
	AreaSubListGET(c *gin.Context, params AreaSubListGETParams)
	// Creates subscription to area notifications.
	// (POST /subscriptions/area)
	AreaSubPOST(c *gin.Context)
	// Cancel a subscription
	// (DELETE /subscriptions/area/{subscriptionId})
	AreaSubDELETE(c *gin.Context, subscriptionId PathSubscrId)
	// Retrieve subscription information
	// (GET /subscriptions/area/{subscriptionId})
	AreaSubGET(c *gin.Context, subscriptionId PathSubscrId)
	// Updates a subscription information
	// (PUT /subscriptions/area/{subscriptionId})
	AreaSubPUT(c *gin.Context, subscriptionId PathSubscrId)
	// Retrieves all active subscriptions to distance change notifications
	// (GET /subscriptions/distance)
	DistanceSubListGET(c *gin.Context)
	// Creates a subscription for distance change notification
	// (POST /subscriptions/distance)
	DistanceSubPOST(c *gin.Context)
	// Cancel a subscription
	// (DELETE /subscriptions/distance/{subscriptionId})
	DistanceSubDELETE(c *gin.Context, subscriptionId PathSubscrId)
	// Retrieve user distance subscription information
	// (GET /subscriptions/distance/{subscriptionId})
	DistanceSubGET(c *gin.Context, subscriptionId PathSubscrId)
	// Updates a user distance subscription information
	// (PUT /subscriptions/distance/{subscriptionId})
	DistanceSubPUT(c *gin.Context, subscriptionId PathSubscrId)
	// Retrieves information about the subscriptions for the requestor
	// (GET /subscriptions/users)
	UserSubListGET(c *gin.Context, params UserSubListGETParams)
	// Create subscription to UE location notifications.
	// (POST /subscriptions/users)
	UserSubPOST(c *gin.Context)
	// Cancel a subscription
	// (DELETE /subscriptions/users/{subscriptionId})
	UserSubDELETE(c *gin.Context, subscriptionId PathSubscrId)
	// Retrieve subscription information
	// (GET /subscriptions/users/{subscriptionId})
	UserSubGET(c *gin.Context, subscriptionId PathSubscrId)
	// Updates a subscription information
	// (PUT /subscriptions/users/{subscriptionId})
	UserSubPUT(c *gin.Context, subscriptionId PathSubscrId)
	// Retrieves all active subscriptions to zone notifications
	// (GET /subscriptions/zones)
	ZoneSubListGET(c *gin.Context, params ZoneSubListGETParams)
	// Creates a subscription to zone notifications
	// (POST /subscriptions/zones)
	ZoneSubPOST(c *gin.Context)
	// Cancel a zone subscription
	// (DELETE /subscriptions/zones/{subscriptionId})
	ZoneSubDELETE(c *gin.Context, subscriptionId PathSubscrId)
	// Retrieve zone subscription information
	// (GET /subscriptions/zones/{subscriptionId})
	ZoneSubGET(c *gin.Context, subscriptionId PathSubscrId)
	// Updates a zone subscription information
	// (PUT /subscriptions/zones/{subscriptionId})
	ZoneSubPUT(c *gin.Context, subscriptionId PathSubscrId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// DistanceGET operation middleware
func (siw *ServerInterfaceWrapper) DistanceGET(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DistanceGETParams

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", c.Request.URL.Query(), &params.Address)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter address: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "location" -------------

	err = runtime.BindQueryParameter("form", true, false, "location", c.Request.URL.Query(), &params.Location)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter location: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DistanceGET(c, params)
}

// UsersGET operation middleware
func (siw *ServerInterfaceWrapper) UsersGET(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersGETParams

	// ------------- Optional query parameter "zoneId" -------------

	err = runtime.BindQueryParameter("form", true, false, "zoneId", c.Request.URL.Query(), &params.ZoneId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter zoneId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "accessPointId" -------------

	err = runtime.BindQueryParameter("form", true, false, "accessPointId", c.Request.URL.Query(), &params.AccessPointId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter accessPointId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", c.Request.URL.Query(), &params.Address)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter address: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UsersGET(c, params)
}

// ZonesGET operation middleware
func (siw *ServerInterfaceWrapper) ZonesGET(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ZonesGETParams

	// ------------- Optional query parameter "zoneId" -------------

	err = runtime.BindQueryParameter("form", true, false, "zoneId", c.Request.URL.Query(), &params.ZoneId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter zoneId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ZonesGET(c, params)
}

// ZoneGetById operation middleware
func (siw *ServerInterfaceWrapper) ZoneGetById(c *gin.Context) {

	var err error

	// ------------- Path parameter "zoneId" -------------
	var zoneId PathZoneId

	err = runtime.BindStyledParameterWithOptions("simple", "zoneId", c.Param("zoneId"), &zoneId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter zoneId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ZoneGetById(c, zoneId)
}

// AccessPointsGET operation middleware
func (siw *ServerInterfaceWrapper) AccessPointsGET(c *gin.Context) {

	var err error

	// ------------- Path parameter "zoneId" -------------
	var zoneId PathZoneId

	err = runtime.BindStyledParameterWithOptions("simple", "zoneId", c.Param("zoneId"), &zoneId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter zoneId: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AccessPointsGETParams

	// ------------- Optional query parameter "accessPointId" -------------

	err = runtime.BindQueryParameter("form", true, false, "accessPointId", c.Request.URL.Query(), &params.AccessPointId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter accessPointId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AccessPointsGET(c, zoneId, params)
}

// AccessPointGetById operation middleware
func (siw *ServerInterfaceWrapper) AccessPointGetById(c *gin.Context) {

	var err error

	// ------------- Path parameter "zoneId" -------------
	var zoneId PathZoneId

	err = runtime.BindStyledParameterWithOptions("simple", "zoneId", c.Param("zoneId"), &zoneId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter zoneId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessPointId" -------------
	var accessPointId PathAccessPointId

	err = runtime.BindStyledParameterWithOptions("simple", "accessPointId", c.Param("accessPointId"), &accessPointId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter accessPointId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AccessPointGetById(c, zoneId, accessPointId)
}

// AreaSubListGET operation middleware
func (siw *ServerInterfaceWrapper) AreaSubListGET(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AreaSubListGETParams

	// ------------- Optional query parameter "subscription_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscription_type", c.Request.URL.Query(), &params.SubscriptionType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscription_type: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AreaSubListGET(c, params)
}

// AreaSubPOST operation middleware
func (siw *ServerInterfaceWrapper) AreaSubPOST(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AreaSubPOST(c)
}

// AreaSubDELETE operation middleware
func (siw *ServerInterfaceWrapper) AreaSubDELETE(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AreaSubDELETE(c, subscriptionId)
}

// AreaSubGET operation middleware
func (siw *ServerInterfaceWrapper) AreaSubGET(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AreaSubGET(c, subscriptionId)
}

// AreaSubPUT operation middleware
func (siw *ServerInterfaceWrapper) AreaSubPUT(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AreaSubPUT(c, subscriptionId)
}

// DistanceSubListGET operation middleware
func (siw *ServerInterfaceWrapper) DistanceSubListGET(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DistanceSubListGET(c)
}

// DistanceSubPOST operation middleware
func (siw *ServerInterfaceWrapper) DistanceSubPOST(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DistanceSubPOST(c)
}

// DistanceSubDELETE operation middleware
func (siw *ServerInterfaceWrapper) DistanceSubDELETE(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DistanceSubDELETE(c, subscriptionId)
}

// DistanceSubGET operation middleware
func (siw *ServerInterfaceWrapper) DistanceSubGET(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DistanceSubGET(c, subscriptionId)
}

// DistanceSubPUT operation middleware
func (siw *ServerInterfaceWrapper) DistanceSubPUT(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DistanceSubPUT(c, subscriptionId)
}

// UserSubListGET operation middleware
func (siw *ServerInterfaceWrapper) UserSubListGET(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserSubListGETParams

	// ------------- Optional query parameter "subscription_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscription_type", c.Request.URL.Query(), &params.SubscriptionType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscription_type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", c.Request.URL.Query(), &params.Address)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter address: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserSubListGET(c, params)
}

// UserSubPOST operation middleware
func (siw *ServerInterfaceWrapper) UserSubPOST(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserSubPOST(c)
}

// UserSubDELETE operation middleware
func (siw *ServerInterfaceWrapper) UserSubDELETE(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserSubDELETE(c, subscriptionId)
}

// UserSubGET operation middleware
func (siw *ServerInterfaceWrapper) UserSubGET(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserSubGET(c, subscriptionId)
}

// UserSubPUT operation middleware
func (siw *ServerInterfaceWrapper) UserSubPUT(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserSubPUT(c, subscriptionId)
}

// ZoneSubListGET operation middleware
func (siw *ServerInterfaceWrapper) ZoneSubListGET(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ZoneSubListGETParams

	// ------------- Optional query parameter "subscription_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscription_type", c.Request.URL.Query(), &params.SubscriptionType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscription_type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "zoneId" -------------

	err = runtime.BindQueryParameter("form", true, false, "zoneId", c.Request.URL.Query(), &params.ZoneId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter zoneId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ZoneSubListGET(c, params)
}

// ZoneSubPOST operation middleware
func (siw *ServerInterfaceWrapper) ZoneSubPOST(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ZoneSubPOST(c)
}

// ZoneSubDELETE operation middleware
func (siw *ServerInterfaceWrapper) ZoneSubDELETE(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ZoneSubDELETE(c, subscriptionId)
}

// ZoneSubGET operation middleware
func (siw *ServerInterfaceWrapper) ZoneSubGET(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ZoneSubGET(c, subscriptionId)
}

// ZoneSubPUT operation middleware
func (siw *ServerInterfaceWrapper) ZoneSubPUT(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId PathSubscrId

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", c.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ZoneSubPUT(c, subscriptionId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/queries/distance", wrapper.DistanceGET)
	router.GET(options.BaseURL+"/queries/users", wrapper.UsersGET)
	router.GET(options.BaseURL+"/queries/zones", wrapper.ZonesGET)
	router.GET(options.BaseURL+"/queries/zones/:zoneId", wrapper.ZoneGetById)
	router.GET(options.BaseURL+"/queries/zones/:zoneId/accessPoints", wrapper.AccessPointsGET)
	router.GET(options.BaseURL+"/queries/zones/:zoneId/accessPoints/:accessPointId", wrapper.AccessPointGetById)
	router.GET(options.BaseURL+"/subscriptions/area", wrapper.AreaSubListGET)
	router.POST(options.BaseURL+"/subscriptions/area", wrapper.AreaSubPOST)
	router.DELETE(options.BaseURL+"/subscriptions/area/:subscriptionId", wrapper.AreaSubDELETE)
	router.GET(options.BaseURL+"/subscriptions/area/:subscriptionId", wrapper.AreaSubGET)
	router.PUT(options.BaseURL+"/subscriptions/area/:subscriptionId", wrapper.AreaSubPUT)
	router.GET(options.BaseURL+"/subscriptions/distance", wrapper.DistanceSubListGET)
	router.POST(options.BaseURL+"/subscriptions/distance", wrapper.DistanceSubPOST)
	router.DELETE(options.BaseURL+"/subscriptions/distance/:subscriptionId", wrapper.DistanceSubDELETE)
	router.GET(options.BaseURL+"/subscriptions/distance/:subscriptionId", wrapper.DistanceSubGET)
	router.PUT(options.BaseURL+"/subscriptions/distance/:subscriptionId", wrapper.DistanceSubPUT)
	router.GET(options.BaseURL+"/subscriptions/users", wrapper.UserSubListGET)
	router.POST(options.BaseURL+"/subscriptions/users", wrapper.UserSubPOST)
	router.DELETE(options.BaseURL+"/subscriptions/users/:subscriptionId", wrapper.UserSubDELETE)
	router.GET(options.BaseURL+"/subscriptions/users/:subscriptionId", wrapper.UserSubGET)
	router.PUT(options.BaseURL+"/subscriptions/users/:subscriptionId", wrapper.UserSubPUT)
	router.GET(options.BaseURL+"/subscriptions/zones", wrapper.ZoneSubListGET)
	router.POST(options.BaseURL+"/subscriptions/zones", wrapper.ZoneSubPOST)
	router.DELETE(options.BaseURL+"/subscriptions/zones/:subscriptionId", wrapper.ZoneSubDELETE)
	router.GET(options.BaseURL+"/subscriptions/zones/:subscriptionId", wrapper.ZoneSubGET)
	router.PUT(options.BaseURL+"/subscriptions/zones/:subscriptionId", wrapper.ZoneSubPUT)
}
